
let passed_count:int = 0;
let total_count:int = 0;

def pass_test()->nil {
    @print(@format("Test case %d: passed\n", [total_count])),
    set passed_count = @addi(passed_count, 1),
    set total_count = @addi(total_count, 1),
    nil
};

def fail_test()->nil {
    @print(@format("Test case %d: failed. ", [total_count])),
    set total_count = @addi(total_count, 1)
};

def require(v:int, msg:array(char))->nil {
    @indexf([
        pass_test, 
        \()->{fail_test(), @print(msg), @print("\n")}:nil
    ], 
    @eqi(v, 0)
    )()
};

def summary()->nil {
    @print(@format("Total %d cases, %d passed, %d failed\n", 
    [total_count, passed_count, @subi(total_count, passed_count)]))
};

# Literals

let vi1:int = 1;
let vi2:int = -1;
let vf1:float = 1.00;
let vc1:char = 'a';
let vc2:char = '\n';
let vs1:array(char) = "";
let vs2:array(char) = "12345";
let vb1:bool = true;
let vn1:nil = nil;
let vn2:nil = ();

# Let/set

require(@eqi(vi1, 1), "1=1\n");
require(@eqi(vi2, -1), "-1=-1\n");
require(@eqf(vf1, 1.00), "1.00=1.00\n");

set vi2 = vi1;
require(@eqi(vi2, vi1), "vi2=vi1\n");

# Type conversion

require(@eqi(@ctoi('1'), 49), "char2int");
require(@eqi(@ctoi(@itoc(49)), 49), "int2char");
require(@eqf(@ctof('1'), 49.0), "char2float");
require(@eqf(@itof(-5), -5.0), "int2float");
require(@eqi(@ftoi(123.9), 123), "float2int");

# Basic Subtyping

let vo1:object = 1;
let vo2:object = 1.0;
let vo3:object = true;
let vo4:object = ["12345"];

set vo1 = "abc";
set vo2 = [[1]];
#set vo3 = {};
#set vo4 = {a=2, b="123"};

let vao1:array(object) = [1,2,3];
set vao1 = "12345";

let vto1:tuple(object, object);
let vt1:tuple(int, int);
set vto1 = vt1;

let vf2:function(int, int);
let vf3:function(int, object);
set vf3 = vf2;

# struct is tested in the future.

# Expression: Aggresion types

let vai1:array(int) = [];
let vaii1:array(array(int)) = [[]];
set vaii1 = [[5]];
set vaii1 = [[5, 6], [4], []];

let vtoo:tuple(object, object) = (1, '2');
let vtia:tuple(int, array(char)) = (1, "2");

# Expression: Lambda

let vfii1:function(int, int, int) = \(x:int, y:int)->@addi(x, y):int;
let vfii2:function(int, int, int) = \(x:int, y:int)->{
    set x = @addi(x, 1), @addi(x, y)
}:int;
let vfi1:function(int) = \()->2:int;
let vfi2:function(int) = \()->{vi1}:int;

require(@eqi(2, vfii1(1, 1)), "1+1=2\n");
require(@eqi(3, vfii2(3, -1)), "4-1=3\n");
require(@eqi(2, vfi1()), "2=2\n");
require(@eqi(1, vfi2()), "1=1\n");

# Some library functions

require(@eqi(@addi(1, 1), 2), "add");
require(@eqi(@subi(3, 1), 2), "sub");
require(@eqi(@muli(-5, -7), 35), "mul");
require(@eqi(@divi(6, 4), 1), "div");
require(@eqi(@modi(6, 5), 1), "mod");
require(@eqi(@negi(5), -5), "neg");
require(@eqi(@andi(1, 0), 0), "and");
require(@eqi(@ori(1, 0), 1), "or");
require(@eqi(@xori(1, 0), 1), "xor");
require(@eqi(@noti(1), 0), "not");
require(@neqi(1, 2), "!=");
require(@lessi(1, 2), "<");
require(@lesseqi(1, 2), "<=");
require(@greateri(2, -1), ">");
require(@greatereqi(-1, -1), ">=");

require(@eqi(@indexi([1,2,3], 2), 3), "indexi");

let va:array(int) = @arrayi(3);
@setindexi(va, 2, 5);
require(@eqi(@indexi(va, 2), 5), "setindexi");
require(@eqi(@sizeof(va), 12), "sizeof");

let s:array(char) = @format("% -+5.5f", [123.45678]);
require(@eqi(@ctoi(@index(s, 4)), 46), "format");
require(@eqi(@ctoi(@index(s, 9)), 56), "format");

summary();

