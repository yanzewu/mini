
# Pre-definitions

import std;
123;
let multiply:function(int, int, int) = @muli;
let add:function(int, int, int) = @addi;
let negate:function(int, int) = @negi;
let pass:function(nil) = \()->{nil}:nil;
let append:function(array(int), int, array(int));

let v1:int;
let v2:int = 10;
let v2_2:int = (10);
let v3:float = 10.23;
let v4:char = '1';
let v4_2:char = '\n';
let v4_3:char = ' ';
let v5:bool = true;
let v8:function(int, array(int), array(int)) =
    \(a:int, l:array(int))->append(l, a):array(int)
;
let v8_2:function(int, array(int), array(int)) =
    \(a:int, l:array(int))->{
        let b:int = add(a, 2),
        append(l, b)
    }:array(int)
;

let v9:int = add(2,3);
let v9_2:int = add(v9, 3);
let v10:function(int, array(int), array(int)) = v8;
let v12:array(int) = [1,2,3];
let v12_2:array(int) = [1,multiply(v2, 2), add(3, 5)];
let v12_3:array(int) = [1];
let v12_4:array(int) = [];
let v12_5:array(array(int)) = [[1]];
let v13:nil = nil;

# function definition

def f1(a:int, b:int)->int {
    add(a, b),
    add(add(a, b), add(a, b)),
    negate(add(a, b)),
    a,
    (a, b),
    ((a), b),
    1,
    add(a, b),
    set a = 5,
    set a = add(a, b),
    let d:int = add(a, b),
    a
};

def f2(a:int, b:int)->nil {
    nil
};

def f3()->int {
    2
};

def f4()->int {
    def nested_f1(a:int, b:int)->int {
        add(a, b),
        add(add(a, b), add(a, b)),
        negate(add(a, b)),
        a,
        (a, b),
        ((a), b),
        1,
        add(a, b),
        set a = 5,
        set a = add(a, b),
        let c:int = add(a, b),
        a
    },
    let nested_v2:int = 10,
    let nested_v3:float = 10.23,
    let nested_v4:char = '1',
    let nested_v4_2:char = '\n',
    let nested_v4_3:char = ' ',
    let nested_v5:bool = true,
    let nested_v8:function(int, array(int), array(int)) =
        \(a:int, l:array(int))->append(l, a):array(int)
    ,
    let nested_v8_2:function(int, array(int), array(int)) =
        \(a:int, l:array(int))->{
            let b:int = add(a, 2),
            let c:int = nested_v2,
            append(l, b)
        }:array(int)
    ,
    let v9:int = add(2,3),
    let v9_2:int = add(v9, 3),
    let v10:function(int, array(int), array(int)) = v8,
    1
};


let uv1:forall<X>.function(X,X);
let uv2:forall<X>.function(X,X) = \<X>(x:X)->x:X;
set uv1 = uv2;
let uv3:function(forall<X>.function(X,X), forall<X>.function(X,X)) = \(f:forall<X>.function(X,X))->{
    \<X>(x:X)->f<X>(f<X>(x)):X
}:forall<X>.function(X,X);

interface I0 {
    a:int
};

def f5<X implements I0>(x:X)->int{
    x.a
};

interface I1 {
    m1:int,
    m2:function(int, int),
    m3:forall<X>.function(X,X)
};

interface I2 extends I1 {
    m4:float
};

interface I3 {
    m5:I1,
    m6:I2
    #m7:I3
};

let i0:I0 = {a=2};
let a0 = i0.a;
let i2:I2 = {m1=1, m2=negate, m3=uv1, m4=2.0};

interface I0_prime {a:int, b:float};

f5<I0_prime>({a=2, b=5.0});
f5<I0>(i0);

class C1 implements I0 {
    a:int,
    virtual f:function(C1,int),
    new (val:int)->{
        set self.a = val,
        set self.f = \(rhs:C1)->@eqi(self.a, rhs.a)
    }
};
let c1 = new C1(1);
set c1.a = 2;

class C2 extends C1 implements I0 {
    f:function(C1,int),
    g:function(C2,int),
    new(val:int, x:array(char)) extends C1(val)->{
        set self.g = \(rhs:C2)->@gei(self.a, rhs.a)
    }
};
let c2:C1 = new C2(2, "2");
let c3 = new C2(2, "2");

f5<C1>(c1);
f5<C1>(c3);
